
R version 4.2.1 (2022-06-23) -- "Funny-Looking Kid"
Copyright (C) 2022 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(pomp)
> library(tidyverse)
── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──
✔ ggplot2 3.3.6     ✔ purrr   0.3.4
✔ tibble  3.1.7     ✔ dplyr   1.0.9
✔ tidyr   1.2.0     ✔ stringr 1.4.0
✔ readr   2.1.2     ✔ forcats 0.5.1
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
✖ purrr::map()    masks pomp::map()
> library(doParallel)
Loading required package: foreach

Attaching package: ‘foreach’

The following objects are masked from ‘package:purrr’:

    accumulate, when

Loading required package: iterators
Loading required package: parallel
> library(doRNG)
Loading required package: rngtools
> options(
+   dplyr.summarise.inform=FALSE,
+   pomp_archive_dir="results"
+   )
> 
> library(tidyverse)
> data <- read_csv(
+   "https://kingaa.github.io/sbied/polio/polio_wisconsin.csv",
+   comment="#")
Rows: 288 Columns: 4
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
dbl (4): time, cases, births, pop

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
> head(data,5)
# A tibble: 5 × 4
   time cases births     pop
  <dbl> <dbl>  <dbl>   <dbl>
1 1931.     7   4698 2990000
2 1931.     0   4354 2990000
3 1931.     7   4836 2990000
4 1931.     3   4468 2990000
5 1931.     4   4712 2990000
> 
> 
> 
> statenames <- c("SB1","SB2","SB3","SB4","SB5","SB6",
+   "IB","SO","IO")
> t0 <- 1932+4/12
> 
> library(pomp)
> K <- 6
> covar <- covariate_table(
+   t=data$time,
+   B=data$births,
+   P=predict(
+     smooth.spline(x=1931:1954,y=data$pop[seq(12,24*12,by=12)]),
+     x=data$time)$y,
+   periodic.bspline.basis(t,nbasis=K,
+     degree=3,period=1,names="xi%d"),
+   times="t"
+ )
> 
> rp_names <- c("b1","b2","b3","b4","b5","b6",
+   "psi","rho","tau","sigma_dem","sigma_env")
> 
> ivp_names <- c("SO_0","IO_0")
> paramnames <- c(rp_names,ivp_names)
> 
> fp_names <- c("delta","K",
+   "SB1_0","SB2_0","SB3_0","SB4_0","SB5_0","SB6_0")
> paramnames <- c(rp_names,ivp_names,fp_names)
> covar_index_t0 <- which(abs(covar@times-t0)<0.01)
> initial_births <- covar@table["B",covar_index_t0-0:5]
> names(initial_births) <- c("SB1_0","SB2_0",
+   "SB3_0","SB4_0","SB5_0","SB6_0") 
> fixed_params <- c(delta=1/60,K=K,initial_births)
> 
> params_guess <- c(
+   b1=3,b2=0,b3=1.5,b4=6,b5=5,b6=3,
+   psi=0.002,rho=0.01,tau=0.001,
+   sigma_dem=0.04,sigma_env=0.5,
+   SO_0=0.12,IO_0=0.001,
+   fixed_params)
> 
> rprocess <- Csnippet("
+ double beta = exp(dot_product( (int) K, &xi1, &b1));
+ double lambda = (beta * (IO+IB) / P + psi);
+ double var_epsilon = pow(sigma_dem,2)/ lambda +  
+   pow(sigma_env,2);
+ lambda *= (var_epsilon < 1.0e-6) ? 1 : 
+   rgamma(1/var_epsilon,var_epsilon);
+ double p = exp(-(delta+lambda)/12);
+ double q = (1-p)*lambda/(delta+lambda);
+ SB1=B;
+ SB2=SB1*p;
+ SB3=SB2*p;
+ SB4=SB3*p;
+ SB5=SB4*p;
+ SB6=SB5*p;
+ SO=(SB6+SO)*p;
+ IB=(SB1+SB2+SB3+SB4+SB5+SB6)*q;
+ IO=SO*q;
+ ")
> 
> dmeasure <- Csnippet("
+ double tol = 1.0e-25;
+ double mean_cases = rho*IO;
+ double sd_cases = sqrt(pow(tau*IO,2) + mean_cases);
+ if(cases > 0.0){
+   lik = pnorm(cases+0.5,mean_cases,sd_cases,1,0)
+     - pnorm(cases-0.5,mean_cases,sd_cases,1,0) + tol; 
+ } else{
+   lik = pnorm(cases+0.5,mean_cases,sd_cases,1,0) + tol;
+ }
+ if (give_log) lik = log(lik);")
> rmeasure <- Csnippet("
+ cases = rnorm(rho*IO, sqrt( pow(tau*IO,2) + rho*IO ) );
+ if (cases > 0.0) {
+   cases = nearbyint(cases);
+ } else {
+   cases = 0.0;
+ }")
> 
> rinit <- Csnippet("
+ SB1 = SB1_0;
+ SB2 = SB2_0;
+ SB3 = SB3_0;
+ SB4 = SB4_0;
+ SB5 = SB5_0;
+ SB6 = SB6_0;
+ IB = 0;
+ IO = IO_0 * P;
+ SO = SO_0 * P;
+ ")
> 
> partrans <- parameter_trans(
+   log=c("psi","rho","tau","sigma_dem","sigma_env"),
+   logit=c("SO_0","IO_0")
+ )
> 
> data %>%
+   filter(
+     time > t0 + 0.01,
+     time < 1953+1/12+0.01
+   ) %>%
+   select(cases,time) %>%
+   pomp(
+     times="time",t0=t0,
+     params=params_guess,
+     rprocess=euler(step.fun=rprocess,delta.t=1/12),
+     rmeasure=rmeasure,
+     dmeasure=dmeasure,
+     rinit=rinit,
+     partrans=partrans,
+     covar=covar,
+     statenames=statenames,
+     paramnames=paramnames
+   ) -> polio
> 
> simulate(polio)
<object of class ‘pomp’>
> 
> 
> run_level <- as.integer(Sys.getenv("RUNLEVEL"))
> stopifnot(`bad runlevel`=isTRUE(run_level %in% c(1,2,3)))
> Np <-          switch(run_level,100, 1e3, 5e3)
> Nmif <-        switch(run_level, 10, 100, 200)
> Nreps_eval <-  switch(run_level,  2,  10,  20)
> Nreps_local <- switch(run_level, 10,  20,  40)
> Nreps_global <-switch(run_level, 10,  20, 100)
> Nsim <-        switch(run_level, 50, 100, 500) 
> 
> ## library(doParallel)
> ## cores <- as.numeric(Sys.getenv('SLURM_NTASKS_PER_NODE',unset=NA))
> ## if(is.na(cores)) cores <- detectCores()
> ## registerDoParallel(cores)
> ## library(doRNG)
> 
> if (file.exists("CLUSTER.R")) {
+   source("CLUSTER.R")
+ }
Loading required package: Rmpi
Master processor name: theorygroup01; nodename: theorygroup01
Size of MPI universe: 1
Spawning 250 workers using the command:
  /export/local/apps/R/ubuntu_18.04/4.2.1/lib64/R/bin/Rscript /userdata/kingaa/R_Ubuntu_18.04/x86_64-pc-linux-gnu-library/4.2/doMPI/RMPIworker.R WORKDIR=/home/kingaa/sbied/polio/runlevel2 LOGDIR=/tmp MAXCORES=1 COMM=3 INTERCOMM=4 MTAG=10 WTAG=11 INCLUDEMASTER=TRUE BCAST=TRUE VERBOSE=TRUE
App launch reported: 12 (out of 12) daemons - 229 (out of 250) procs
Error in mpi.comm.spawn(slave = rscript, slavearg = args, nslaves = count,  : 
  MPI_ERR_SPAWN: could not spawn processes
Calls: source ... withVisible -> eval -> eval -> startMPIcluster -> mpi.comm.spawn
Execution halted
