---
title: Parallel pomp computations under Windows
author: Aaron A. King and Edward L. Ionides
output:
  html_document:
    toc: no
    includes:
      after_body:
      - ../_includes/supp_bottom.html
      - ../_includes/license.html
bibliography: ../sbied.bib
csl: ../jss.csl
params:
  prefix: windows
---

-----------------------------------


```{r knitr-opts}
#| include: false
#| purl: false
source("../_includes/setup.R", local = knitr::knit_global())
```
```{r checks}
#| cache: false
#| include: false
set.seed(1350254336)
```

Some Windows users have reported trouble with the parallel codes used in several of the Lessons.
Specifically, **pomp** codes that require compilation of C snippets trigger errors when executed in parallel on certain Windows machines.

Calls that induce compilation include:

1. Every call to a **pomp** function in which a basic model component is specified using a C snippet.
Recall that the basic model components include `rmeasure`, `dmeasure`, `rprocess`, `dprocess`, `skeleton`, `rprior`, `dprior`, `partrans`, and `rinit`.
Whenever one of these arguments is furnished a `Csnippet`, the snippet is compiled.  
2. Every call to a **pomp** function in which a parameter transformation is specified by giving the names of parameters to log-transform, logit-transform, or log-barycentric transform.
Even though the user does not supply a `Csnippet` in such cases, each such call results in a `Csnippet` being written internally, and then compiled.

In addition, the use of temporary directories to hold the C files and dynamically loadable libraries created from them that underlie the C snippet facility causes problems on certain Windows machines.
We hypothesize that this is due to Windows securities features.

The workaround is to execute *serially* all codes that require compilation;
that is, to execute them *outside* of all parallel code blocks.
Also, one can dictate to **pomp** that all compilation should be done in the current working directory.
The easiest way to do this is to give a global option indicating to which directory the C files should be written.

For example, the first of the following commands creates a temporary directory under the current working directory (recall that you can execute `getwd()` to find out where that is).
The second command sets a global option, with the effect that every **pomp** compilation operation will be performed in that directory.

```{r cdir}
#| eval: true
dir.create("tmp")
options(pomp_cdir="./tmp")
```

As an illustration, we will consider two code chunks.
Before we do so, we load some packages, set up a parallel environment, and build the SIR model we have seen in the Lessons.
The latter is stored in an object named `measSIR`.

```{r snip0}
#| message: false
#| results: hide
library(tidyverse)
library(pomp)

library(doParallel)
d <- detectCores()
registerDoParallel(d-1)

sir_step <- Csnippet("
  double dN_SI = rbinom(S,1-exp(-Beta*I/N*dt));
  double dN_IR = rbinom(I,1-exp(-mu_IR*dt));
  S -= dN_SI;
  I += dN_SI - dN_IR;
  R += dN_IR;
  H += dN_IR;
")

sir_init <- Csnippet("
  S = nearbyint(eta*N);
  I = 1;
  R = nearbyint((1-eta)*N);
  H = 0;
")

dmeas <- Csnippet("
  lik = dnbinom_mu(reports,k,rho*H,give_log);
  ")

rmeas <- Csnippet("
  reports = rnbinom_mu(k,rho*H);
  ")

read_csv("https://kingaa.github.io/sbied/pfilter/Measles_Consett_1948.csv") %>%
  select(week,reports=cases) %>%
  filter(week<=42) %>%
  pomp(
    times="week", t0=0,
    rprocess=euler(sir_step,delta.t=1/7),
    rinit=sir_init,
    rmeasure=rmeas,
    dmeasure=dmeas,
    accumvars="H",
    statenames=c("S","I","R","H"),
    paramnames=c("Beta","mu_IR","eta","rho","k","N"),
    params=c(Beta=15,mu_IR=0.5,rho=0.5,k=10,eta=0.06,N=38000)
  ) -> measSIR

```

Now compare the following two code chunks.
The first produces an error on many Windows machines:
	
```{r snip1}
#| message: false
#| results: hide
foreach (i=1:4,.combine=c) %dopar% {
  library(pomp)
  measSIR %>%
    mif2(
      Np=1000, Nmif=5,
      cooling.fraction.50=0.5,
      rw.sd=rw.sd(Beta=0.2, rho=0.2, eta=ivp(0.2)),
### Compilation is triggered here, by the call to `parameter_trans`.
      partrans=parameter_trans(log="Beta",logit=c("rho","eta")),
      paramnames=c("Beta","rho","eta")
    )
} -> mifs_local
```

The next one does not:

```{r snip2}
#| message: false
#| results: hide
measSIR %>%
  pomp(
### Compilation is triggered here, outside the parallel block.
    partrans=parameter_trans(log="Beta",logit=c("rho","eta")),
    paramnames=c("Beta","rho","eta")
  ) -> measSIR2

foreach (i=1:4,.combine=c) %dopar% {
### No compilation is triggered inside the parallel code block.
  library(pomp)
  measSIR2 %>%
    mif2(
      Np=1000, Nmif=5,
      cooling.fraction.50=0.5,
      rw.sd=rw.sd(Beta=0.2, rho=0.2, eta=ivp(0.2))
    )
} -> mifs_local
```

The only difference between the code chunks is that, in the first, compilation is needed *inside* the parallel code block;
In the second, the compilation is done *before* the parallelization, via the call to `pomp`.

-----------------------------------
	
[**R codes for this document**](./windows.R)  

